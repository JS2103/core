// grpc2rest contains methods for converting Kubernetes-style REST to gRPC.
//
// It contains a Method class that has all request-time information, and
// a ResourceInfoRepository class responsible for creating Method instances.
package grpc2rest

import (
	"errors"
	"fmt"
	"io"
	"log"
	"strconv"
	"strings"

	"github.com/golang/protobuf/proto"
	"github.com/golang/protobuf/protoc-gen-go/descriptor"
	"github.com/jhump/protoreflect/dynamic"
	"k8s.io/client-go/rest"
)

// Request is an interface for the subset of k8s.io/client-go/rest.Request
// that this code uses. The semantics are the same as rest.Request and repeated
// below because rest.Request is poorly documented.
type Request interface {
	// DoRaw returns a body with a single JSON message of the message's
	// GetOutputMessage() type on success. On error, body may contain JSON
	// with an instance of k8s.io/apimachinery/pkg/apis/meta/v1.Status.
	DoRaw() ([]byte, error)
	// Stream returns a stream with JSON messages. Each message is a
	// k8s.io/apimachinery/pkg/apis/meta/v1.WatchEvent instance. The object
	// in the WatchEvent may either be a regular object (in which case the
	// GetOutputMessage() can parse the entire JSON), or an meta/v1.Status.
	Stream() (io.ReadCloser, error)
}

// Method abstracts the semantics of a Kubernetes gRPC method.
type Method interface {
	// GetInputMessage returns the proto message for gRPC input.
	// e.g. GetHelloWorldRequest for K8sHelloWorld.Get.
	GetInputMessage() proto.Message
	// GetOutputMessage returns the proto message for gRPC output.
	// e.g. HelloWorld for K8sHelloWorld.Get.
	GetOutputMessage() proto.Message
	// BuildKubernetesRequest builds a HTTP request for the gRPC input.
	// Must be passed a message generated by GetInputMessage.
	BuildKubernetesRequest(proto.Message) (Request, error)
	// IsWatchCall returns true if the call is a Kubernetes Watch call.
	// Watch calls must be read with Stream() instead of DoRaw() and may
	// return objects that can't be parsed by GetOutputMessage().
	IsWatchCall() bool
}

type k8sRequestParams struct {
	inMessage            proto.Message
	outMessage           proto.Message
	verb                 string // HTTP verb for REST ("POST")
	optionsAsQueryParams bool   // copy options from proto to ? URL params
	setWatchParam        bool   // force ?watch to true
	nameInPath           bool   // put the resource's name into the URL path
	namePath             string // proto path (a.b.c) to the name field
	setKindAndApiGroup   bool   // override kind/apiVersion in object field
	namespacePath        string // proto path (a.b.c) to the namespace field
	namespaceDefaults    bool   // whether empty namespace is "default" (true) or all namespaces (false)
	isWatch              bool   // whether the response is streaming
	isNamespacedResource bool   // whether this resource is namespaced (vs cluster-scoped)
	bodyFieldName        string // name of the field that goes into the body
	kind                 string // camel-case Kind ("HelloWorld")
	kindPlural           string // lower-case plural of Kind ("helloworlds")
	apiVersion           string // apiVersion including group ("foo.com/v1")
	client               rest.Interface
}

func (params *k8sRequestParams) GetInputMessage() proto.Message {
	return proto.Clone(params.inMessage)
}

func (params *k8sRequestParams) GetOutputMessage() proto.Message {
	return proto.Clone(params.outMessage)
}

func (params *k8sRequestParams) BuildKubernetesRequest(msg proto.Message) (Request, error) {
	inMessage := msg.(*dynamic.Message)

	// Add Kind and ApiGroup if necessary.
	if params.setKindAndApiGroup {
		objectInterface, err := inMessage.TryGetFieldByName("object")
		if err != nil {
			return nil, errors.New("missing field: 'object'")
		}
		object, ok := objectInterface.(*dynamic.Message)
		if !ok {
			return nil, errors.New("object is not a message")
		}
		if err := object.TrySetFieldByName("kind", params.kind); err != nil {
			return nil, errors.New("object has no 'kind' field")
		}
		if err := object.TrySetFieldByName("apiVersion", params.apiVersion); err != nil {
			return nil, errors.New("object has no 'apiVersion' field")
		}
	}

	// Create Kubernetes request.
	req := params.client.Verb(params.verb).Resource(params.kindPlural)
	if params.isNamespacedResource {
		namespace, err := getStringField(params.namespacePath, inMessage)
		if err != nil {
			return nil, fmt.Errorf("unable to determine namespace: %v", err)
		}
		if params.namespaceDefaults && namespace == "" {
			namespace = "default"
		}
		req = req.Namespace(namespace)
	}
	// Set resource name.
	if params.nameInPath {
		name, err := getStringField(params.namePath, inMessage)
		if err != nil {
			return nil, fmt.Errorf("unable to determine resource name: %v", err)
		}
		if name == "" {
			return nil, fmt.Errorf("empty name is not allowed for this method")
		}
		req = req.Name(name)
	}
	// Set query params.
	if params.optionsAsQueryParams {
		queryParams, err := getQueryParams(inMessage)
		if err != nil {
			return nil, fmt.Errorf("error determining query parameters: %v", err)
		}
		for k, v := range queryParams {
			if !(params.setWatchParam && k == "watch") {
				req = req.Param(k, v)
			}
		}
		if params.setWatchParam {
			req = req.Param("watch", "true")
		}
	}
	// Set body.
	if params.bodyFieldName != "" {
		body, err := getBody(inMessage, params.bodyFieldName)
		if err != nil {
			return nil, fmt.Errorf("unable to create request body: %v", err)
		}
		req = req.Body(body)
	}

	return req, nil
}

func (params *k8sRequestParams) IsWatchCall() bool {
	return params.isWatch
}

func getStringField(path string, msg *dynamic.Message) (string, error) {
	var (
		field interface{}
		err   error
		ok    bool
	)
	parts := strings.Split(path, ".")
	submsg := msg
	for i, p := range parts {
		field, err = submsg.TryGetFieldByName(p)
		if err != nil {
			return "", fmt.Errorf("unable to find field %q in %s", strings.Join(parts[0:i+1], "."), proto.MessageName(msg))
		}
		if i < len(parts)-1 {
			submsg, ok = field.(*dynamic.Message)
			if !ok {
				return "", fmt.Errorf("field %q of %s is not a message", strings.Join(parts[0:i+1], "."), proto.MessageName(msg))
			}
		}
	}
	result, ok := field.(string)
	if !ok {
		return "", fmt.Errorf("field %q of %s is not a string", path, proto.MessageName(msg))
	}
	return result, nil
}

func getBody(message *dynamic.Message, fieldName string) ([]byte, error) {
	obj, err := message.TryGetFieldByName(fieldName)
	if err != nil {
		return nil, fmt.Errorf("unable to extract field %q: %v", fieldName, err)
	}
	bodyMessage, ok := obj.(*dynamic.Message)
	if !ok {
		return nil, fmt.Errorf("%q is not a message", fieldName)
	}
	body, err := bodyMessage.MarshalJSON()
	if err != nil {
		return nil, fmt.Errorf("unable to marshal body message to JSON: %v", err)
	}
	return body, nil
}

func getQueryParams(message *dynamic.Message) (map[string]string, error) {
	optionsInterface, err := message.TryGetFieldByName("options")
	if err != nil {
		return nil, errors.New("unknown field: options")
	}
	options, ok := optionsInterface.(*dynamic.Message)
	if !ok {
		return nil, errors.New("options is not a message")
	}
	queryParams := make(map[string]string)
	if options != nil {
		optionFields := options.GetKnownFields()
		for _, f := range optionFields {
			if options.HasField(f) {
				optionName := f.GetName()
				optionType := f.GetType()
				optionValueInterface := options.GetField(f)
				var optionValue string
				ok = false
				switch optionType {
				case descriptor.FieldDescriptorProto_TYPE_STRING:
					// TODO(daschmidt): Do we need to handle repeated string fields?
					// (Case in point: UpdateOptions.dryRun)
					optionValue, ok = optionValueInterface.(string)
				case descriptor.FieldDescriptorProto_TYPE_INT64:
					var optionValueInt64 int64
					optionValueInt64, ok = optionValueInterface.(int64)
					optionValue = strconv.FormatInt(optionValueInt64, 10)
				case descriptor.FieldDescriptorProto_TYPE_BOOL:
					var optionValueBool bool
					optionValueBool, ok = optionValueInterface.(bool)
					optionValue = strconv.FormatBool(optionValueBool)
				}
				if ok {
					queryParams[optionName] = optionValue
				} else {
					log.Printf("unable to process option field %s.", optionName)
				}
			}
		}
	}
	return queryParams, nil
}
