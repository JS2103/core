// grpc2rest contains methods for converting Kubernetes-style REST to gRPC.
//
// It contains a Method class that has all request-time information, and
// a ResourceInfoRepository class responsible for creating Method instances.
package grpc2rest

import (
	"errors"
	"fmt"
	"io"
	"log"
	"net/url"
	"strconv"

	"github.com/golang/protobuf/proto"
	"github.com/golang/protobuf/protoc-gen-go/descriptor"
	"github.com/jhump/protoreflect/dynamic"
)

// Request is an interface for the subset of k8s.io/client-go/rest.Request
// that this code uses. The semantics are the same as rest.Request and repeated
// below because rest.Request is poorly documented.
type Request interface {
	// DoRaw returns a body with a single JSON message of the message's
	// GetOutputMessage() type on success. On error, body may contain JSON
	// with an instance of k8s.io/apimachinery/pkg/apis/meta/v1.Status.
	DoRaw() ([]byte, error)
	// Stream returns a stream with JSON messages. Each message is a
	// k8s.io/apimachinery/pkg/apis/meta/v1.WatchEvent instance. The object
	// in the WatchEvent may either be a regular object (in which case the
	// GetOutputMessage() can parse the entire JSON), or an meta/v1.Status.
	Stream() (io.ReadCloser, error)
	// URL returns the URL that the request would query.
	URL() *url.URL
}

// Method abstracts the semantics of a Kubernetes gRPC method.
type Method interface {
	// GetInputMessage returns the proto message for gRPC input.
	// e.g. GetHelloWorldRequest for K8sHelloWorld.Get.
	GetInputMessage() proto.Message
	// GetOutputMessage returns the proto message for gRPC output.
	// e.g. HelloWorld for K8sHelloWorld.Get.
	GetOutputMessage() proto.Message
	// BuildKubernetesRequest builds a HTTP request for the gRPC input.
	// Must be passed a message generated by GetInputMessage.
	BuildKubernetesRequest(proto.Message) (Request, error)
	// IsStreamingCall returns true if the call streams responses.
	IsStreamingCall() bool
}

type k8sRequestParams struct {
	resource             *resourceInfo
	inMessageName        string
	outMessageName       string
	verb                 string
	optionsAsQueryParams bool
	setWatchParam        bool
	nameInPath           bool
	setKindAndApiGroup   bool
	isStreaming          bool
	bodyFieldName        string
}

func (params *k8sRequestParams) GetInputMessage() proto.Message {
	msg, err := params.resource.GetMessage(params.inMessageName)
	if err != nil {
		log.Fatal("Invalid CR: Missing message %s", params.inMessageName)
	}
	return msg
}

func (params *k8sRequestParams) GetOutputMessage() proto.Message {
	msg, err := params.resource.GetMessage(params.outMessageName)
	if err != nil {
		log.Fatal("Invalid CR: Missing message %s", params.outMessageName)
	}
	return msg
}

func (params *k8sRequestParams) BuildKubernetesRequest(msg proto.Message) (Request, error) {
	inMessage := msg.(*dynamic.Message)
	resource := params.resource

	// Add Kind and ApiGroup if necessary.
	if params.setKindAndApiGroup {
		objectInterface, err := inMessage.TryGetFieldByName("object")
		if err != nil {
			return nil, errors.New("missing field: 'object'")
		}
		object, ok := objectInterface.(*dynamic.Message)
		if !ok {
			return nil, errors.New("object is not a message")
		}
		if err := object.TrySetFieldByName("kind", resource.Kind); err != nil {
			return nil, errors.New("object has no 'kind' field")
		}
		if err := object.TrySetFieldByName("apiVersion", resource.APIVersion); err != nil {
			return nil, errors.New("object has no 'apiVersion' field")
		}
	}

	// Create Kubernetes request.
	req := resource.Client.Verb(params.verb).Resource(resource.KindPlural).Namespace("default")
	// Set resource name.
	if params.nameInPath {
		name, err := getName(inMessage)
		if err != nil {
			return nil, fmt.Errorf("unable to determine resource name: %v", err)
		}
		req = req.Name(name)
	}
	// Set query params.
	if params.optionsAsQueryParams {
		queryParams, err := getQueryParams(inMessage)
		if err != nil {
			return nil, fmt.Errorf("error determining query parameters: %v", err)
		}
		for k, v := range queryParams {
			if !(params.setWatchParam && k == "watch") {
				req = req.Param(k, v)
			}
		}
		if params.setWatchParam {
			req = req.Param("watch", "true")
		}
	}
	// Set body.
	if params.bodyFieldName != "" {
		body, err := getBody(inMessage, params.bodyFieldName)
		if err != nil {
			return nil, fmt.Errorf("unable to create request body: %v", err)
		}
		req = req.Body(body)
	}

	return req, nil
}

func (params *k8sRequestParams) IsStreamingCall() bool {
	return params.isStreaming
}

func getName(message *dynamic.Message) (string, error) {
	// Try field name "name".
	nameInterface, err := message.TryGetFieldByName("name")
	if err != nil {
		// Try field name "object".
		objInterface, err := message.TryGetFieldByName("object")
		if err != nil {
			return "", fmt.Errorf("unable to extract field 'name' or 'object': %v", err)
		}
		objMessage, ok := objInterface.(*dynamic.Message)
		if !ok {
			return "", errors.New("'object' is not a message")
		}
		metaInterface, err := objMessage.TryGetFieldByName("metadata")
		if err != nil {
			return "", fmt.Errorf("unable to extract field 'metadata': %v", err)
		}
		metaMessage, ok := metaInterface.(*dynamic.Message)
		if !ok {
			return "", errors.New("'metadata' is not a message")
		}
		nameInterface, err = metaMessage.TryGetFieldByName("name")
		if err != nil {
			return "", fmt.Errorf("unable to extract field 'name': %v", err)
		}
	}
	name, ok := nameInterface.(string)
	if !ok {
		return "", errors.New("'name' is not a string")
	}
	return name, nil
}

func getBody(message *dynamic.Message, fieldName string) ([]byte, error) {
	obj, err := message.TryGetFieldByName(fieldName)
	if err != nil {
		return nil, fmt.Errorf("unable to extract field %q: %v", fieldName, err)
	}
	bodyMessage, ok := obj.(*dynamic.Message)
	if !ok {
		return nil, fmt.Errorf("%q is not a message", fieldName)
	}
	body, err := bodyMessage.MarshalJSON()
	if err != nil {
		return nil, fmt.Errorf("unable to marshal body message to JSON: %v", err)
	}
	return body, nil
}

func getQueryParams(message *dynamic.Message) (map[string]string, error) {
	optionsInterface, err := message.TryGetFieldByName("options")
	if err != nil {
		return nil, errors.New("unknown field: options")
	}
	options, ok := optionsInterface.(*dynamic.Message)
	if !ok {
		return nil, errors.New("options is not a message")
	}
	queryParams := make(map[string]string)
	if options != nil {
		optionFields := options.GetKnownFields()
		for _, f := range optionFields {
			if options.HasField(f) {
				optionName := f.GetName()
				optionType := f.GetType()
				optionValueInterface := options.GetField(f)
				var optionValue string
				ok = false
				switch optionType {
				case descriptor.FieldDescriptorProto_TYPE_STRING:
					// TODO(daschmidt): Do we need to handle repeated string fields?
					// (Case in point: UpdateOptions.dryRun)
					optionValue, ok = optionValueInterface.(string)
				case descriptor.FieldDescriptorProto_TYPE_INT64:
					var optionValueInt64 int64
					optionValueInt64, ok = optionValueInterface.(int64)
					optionValue = strconv.FormatInt(optionValueInt64, 10)
				case descriptor.FieldDescriptorProto_TYPE_BOOL:
					var optionValueBool bool
					optionValueBool, ok = optionValueInterface.(bool)
					optionValue = strconv.FormatBool(optionValueBool)
				}
				if ok {
					queryParams[optionName] = optionValue
				} else {
					log.Printf("unable to process option field %s.", optionName)
				}
			}
		}
	}
	return queryParams, nil
}
